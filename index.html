<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="n8n Landing - Automate Workflows im Neon-Style!">
    <title>n8n Landingpage - Neon Darkmode</title>
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap">
    <style>
        /* Three.js Canvas Background Styling */
        #threejs-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background: #000;
        }
        
        /* Dark overlay for better contrast */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: -1;
            pointer-events: none;
        }
        
        /* Ensure body is transparent to show background */
        body {
            margin: 0;
            background: transparent;
            position: relative;
            overflow-x: hidden;
        }
        
        /* Responsive Navigation Menu Styles */
        nav {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            padding: 20px 10px;
            background: rgba(0, 0, 0, 0.8);
            border-bottom: 2px solid #FF0080;
        }
        
        nav a {
            color: #FF0080;
            text-decoration: none;
            padding: 10px 20px;
            border: 2px solid #FF0080;
            border-radius: 5px;
            transition: all 0.3s ease;
            font-size: 16px;
            white-space: nowrap;
        }
        
        nav a:hover {
            background: #FF0080;
            color: #000;
            box-shadow: 0 0 15px #FF0080;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            nav {
                flex-direction: column;
                gap: 10px;
            }
            
            nav a {
                width: 80%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation for Home and Netzwerkeditor -->
    <nav>
        <a href="index.html">Home</a>
        <a href="feature.html">Netzwerkeditor</a>
    </nav>

    <!-- Three.js Library -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
            }
        }
    </script>

    <!-- Three.js Canvas for 3D Background -->
    <canvas id="threejs-canvas"></canvas>
    
    <!-- Original Page Content -->
    <nav>
        <a href="#home">Home</a>
        <a href="#features">Features</a>
        <a href="#pricing">Pricing</a>
        <a href="#contact">Contact</a>
    </nav>
    
    <main style="position: relative; z-index: 1; padding: 40px 20px; color: #FF0080; font-family: 'Orbitron', sans-serif; text-align: center;">
        <h1 style="font-size: 3em; margin-bottom: 20px; text-shadow: 0 0 10px #FF0080;">n8n Landingpage</h1>
        <p style="font-size: 1.5em; color: #fff;">Automate Workflows im Neon-Style!</p>
    </main>
    
    <!-- Three.js 3D Background Script with OrbitControls -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        let camera, scene, renderer, controls;
        let mesh;
        
        init();
        animate();
        
        function init() {
            const canvas = document.getElementById('threejs-canvas');
            
            // Camera
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 10, 20);
            camera.lookAt(0, 0, 0);
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 10, 50);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xFF0080, 0.3);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xFF0080, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x00FFFF, 1, 100);
            pointLight.position.set(0, 5, 0);
            scene.add(pointLight);
            
            // Grid Helper
            const gridHelper = new THREE.GridHelper(50, 50, 0xFF0080, 0x00FFFF);
            scene.add(gridHelper);
            
            // Axes Helper
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // Polar Grid Helper
            const polarGridHelper = new THREE.PolarGridHelper(10, 16, 8, 64, 0xFF0080, 0x00FFFF);
            polarGridHelper.position.y = 0.1;
            scene.add(polarGridHelper);
            
            // Create 3D objects - Torus Knot (like in the demo)
            const geometry = new THREE.TorusKnotGeometry(3, 1, 128, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xFF0080,
                roughness: 0.3,
                metalness: 0.8,
                wireframe: false
            });
            mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 5, 0);
            scene.add(mesh);
            
            // Wireframe overlay
            const wireframeGeometry = new THREE.TorusKnotGeometry(3, 1, 128, 16);
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00FFFF,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const wireframeMesh = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
            mesh.add(wireframeMesh);
            
            // Box Helper for the mesh
            const boxHelper = new THREE.BoxHelper(mesh, 0x00FFFF);
            scene.add(boxHelper);
            
            // Additional geometric shapes
            const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: 0x00FFFF,
                roughness: 0.4,
                metalness: 0.6
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(-8, 3, -5);
            scene.add(sphere);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // OrbitControls - Enable mouse zoom & rotation with damping
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI / 1.5;
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate the main mesh
            if (mesh) {
                mesh.rotation.x += 0.005;
                mesh.rotation.y += 0.01;
            }
            
            // Update controls for smooth damping
            controls.update();
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
